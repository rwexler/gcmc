#######################################
#	Cubic Silicon Carbide (3C-SiC)
# Fix GCMC Test
#	Using Tersoff Potential
#######################################

units		metal
atom_style	atomic
dimension	3
boundary	p p f

variable			seed1 index 12345
variable 			seed2 index 98765
variable			suffix index ""
# these are index variables in case they are to be iterated over or set from the commandline"
variable			si_mu_ex index 5.0
variable			c_mu_ex index 5.5

variable			massSi equal 28.086000
variable			massC equal 12.011150
variable			lat_const equal 4.3596

variable			myTemp equal 500
variable			pressSi equal 0.1
variable 			pressC equal 0.1
# typical interatomic distance for displacement
variable			disp equal $(1.0*v_lat_const)
variable			lbox index 3.0
variable			lzbox index 1.0

variable			h equal 4.135667e-3				# in eV*ps
variable			kT equal "8.617333e-5*v_myTemp"
variable			broglieSi equal "sqrt( v_h^2 /(2*PI*v_massSi*v_kT) )"
variable			broglieC equal "sqrt( v_h^2 /(2*PI*v_massC*v_kT) )"
variable			si_mu_id equal "v_kT*ln( v_pressSi*v_broglieSi^3/v_kT )"
variable			c_mu_id equal "v_kT*ln( v_pressC*v_broglieC^3/v_kT )"

variable			si_mu equal $(v_si_mu_id + v_si_mu_ex)
variable			c_mu equal $(v_c_mu_id + v_c_mu_ex)

# Lattice Constants a = 4.3596 A c = 4.3596 A for 100 3C-SiC
lattice custom ${lat_const} &
a1 1.0 0.0 0.0 &
a2 0.0 1.0 0.0 &
a3 0.0 0.0 1.0 &
basis 0.0 0.0 0.0 &
basis 0.5 0.0 0.5 &
basis 0.0 0.5 0.5 &
basis 0.5 0.5 0.0 &
basis 0.25 0.25 0.25  &
basis 0.75 0.25 0.75  &
basis 0.25 0.75 0.75 &
basis 0.75 0.75 0.25 & 
orient x 1 0 0	&
orient y 0 1 0 &
orient z 0 0 1

# make the z direction twice as long
# The box extends 1 lattice unit 4.5 A above the surface
region whole block 0 ${lbox} 0 ${lbox} $(-v_lzbox-1) $(v_lzbox)  units lattice
create_box 4 whole

region dynamic block EDGE EDGE EDGE EDGE $(-v_lzbox) EDGE units lattice
region add block EDGE EDGE EDGE EDGE 0 EDGE units lattice

mass 1  ${massSi}
mass 2  ${massC}

mass 3 ${massSi}
mass 4 ${massC}

#read_dump		dumps/struct.init 10000 x y z add yes
read_dump		struct.init 10000 x y z add yes
reset_timestep		0

# create_atoms		1 random 2 12345 add
# create_atoms		2 random 2 98765 add

group				groupSi type 1 
group				groupC type 2 
group				mdatoms union groupC groupSi

group				frozenSi type 3
group				frozenC type 4
group				frozen_atoms union frozenSi frozenC

variable			nSi equal count(groupSi)
variable			nC equal count(groupC)

# ---------- Define Interatomic Potential ---------------------#
# use hybrid pair style bcause I don't want any potential for 3* 3* because they don't move anyway
# I want 1*2 3* to still interact though 
pair_style 			tersoff/table
pair_coeff			* * /home/wwatk/gcmc/lammps/SiC.tersoff Si C Si C
# I found that hybrid slows it down:
# 4 threads: no hybrid 2750 t/s vs hybrid 2450 t/s
# 8 threads: no hybrid 3800 t/s vs hybrid 3500 t/s
# pair_coeff			3* 3* none
neighbor			1.0 bin
# exclude type 3 3 exluce type 4 4 will remove the frozen pair interaction from being calculated
# we still want interactions between the slab and the dynamic atoms though
neigh_modify			delay 0 every 1 check yes exclude type 3 3 exclude type 4 4

# minimize                        1.0e-4 1.0e-6 50 500
# gaussian initializiaton with velocity Anderson rescaling to get the exact right temperaure with compute
velocity			mdatoms create ${myTemp} ${seed1}

dump				mydump all xyz 100 dumps/muSi$(v_si_mu:%2.2f)_muC$(v_c_mu:%2.2f)${suffix}.xyz
log				logs/muSi$(v_si_mu:%2.2f)_muC$(v_c_mu:%2.2f)${suffix}.lammps

print				"muSi $(v_si_mu:%2.2f) and muC $(v_c_mu:%2.2f)"

timestep			0.0001

# need dynamic dof bc I add particles ( 3 more per particle)
compute				mdtemp mdatoms temp
compute_modify			mdtemp dynamic/dof yes

fix				mynvt mdatoms nvt temp ${myTemp} ${myTemp} $(100.0*dt) drag 0.0
fix_modify			mynvt temp mdtemp

fix				freeze frozen_atoms setforce 0.0 0.0 0.0

# do N MC moves every step so that one MD timestep equals one MC cycle
# 0.1 GC steps every 1 timestep, so that 10 MC cycles go by between each GC attempt on average
fix				gcmcSi groupSi cbgcmc 10 1 0 1 ${seed1} ${myTemp} ${si_mu} ${disp} region dynamic full_energy max_cutoff 3.7 overlap_cutoff 1.5
fix				gcmcC  groupC  cbgcmc 10 1 0 2 ${seed2} ${myTemp} ${c_mu} ${disp} region dynamic full_energy max_cutoff 3.7 overlap_cutoff 1.5

# fix				mcSi groupSi gcmc 10 0 ${nSi} 1 12345 ${myTemp} ${si_mu} ${disp} full_energy region dynamic
# fix				mcC  groupC  gcmc 10 0 ${nC}  2 98765 ${myTemp} ${c_mu}  ${disp} full_energy region dynamic

# fix					swapFix mdatoms atom/swap 1 10 34567 ${myTemp} semi-grand yes types 1 2 mu ${si_mu} ${c_mu}

# the probability of translation is based on mcSI and mcC fixes
variable			taccSi equal f_mcSi[2]/(f_mcSi[1]+0.1)
variable			iaccSi equal f_gcmcSi[4]/(f_gcmcSi[3]+0.1)
variable			daccSi equal f_gcmcSi[6]/(f_gcmcSi[5]+0.1)

variable			taccC equal f_mcC[2]/(f_mcC[1]+0.1)
variable			iaccC equal f_gcmcC[4]/(f_gcmcC[3]+0.1)
variable			daccC equal f_gcmcC[6]/(f_gcmcC[5]+0.1)

run				0
variable			reduced_pe equal "pe - v_c_mu*v_nC - v_si_mu*v_nSi"

thermo				100
# step temperature PE v v insertion_prob deletion_prob insertion_prob deletion_prob translation_acc translation_acc
thermo_style			custom step temp pe v_reduced_pe v_nSi v_nC f_gcmcSi[4] f_gcmcSi[6] f_gcmcC[4] f_gcmcC[6] #v_taccSi v_taccC
thermo_modify temp mdtemp

# other useful parameters: f_widomSi[1] f_widomSi[2] f_widomC[1] f_widomC[2] f_swapFix[2]
# thermo_style	custom step temp pe v_nSi v_nC f_gcmcSi[4] f_gcmcSi[6] f_gcmcC[4] f_gcmcC[6] f_gcmcSi[3] f_gcmcSi[5]
# thermo_modify	lost warn

run					100000
